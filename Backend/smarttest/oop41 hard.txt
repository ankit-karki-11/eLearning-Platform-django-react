[
  {
    "topic": 37,
    "question_text": "What is 'garbage collection' in OOP languages?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Automatic memory management that reclaims memory occupied by objects that are no longer in use",
        "is_correct": true
      },
      {
        "option_text": "Deleting files from the system",
        "is_correct": false
      },
      {
        "option_text": "Organizing code into modules",
        "is_correct": false
      },
      {
        "option_text": "Sorting data structures",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What distinguishes an abstract class from an interface in languages that support both?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Abstract classes can have implemented methods and state, while interfaces typically cannot (in older versions)",
        "is_correct": true
      },
      {
        "option_text": "Interfaces can be instantiated",
        "is_correct": false
      },
      {
        "option_text": "Abstract classes cannot have method implementations",
        "is_correct": false
      },
      {
        "option_text": "There is no difference",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the key difference between abstract classes and interfaces?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Abstract classes can have method implementations, while interfaces cannot (in most languages)",
        "is_correct": true
      },
      {
        "option_text": "Interfaces can be instantiated, but abstract classes cannot",
        "is_correct": false
      },
      {
        "option_text": "Abstract classes support multiple inheritance, interfaces do not",
        "is_correct": false
      },
      {
        "option_text": "There is no difference",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the purpose of the 'final' keyword in some OOP languages?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "To prevent inheritance or overriding",
        "is_correct": true
      },
      {
        "option_text": "To make a class abstract",
        "is_correct": false
      },
      {
        "option_text": "To allow multiple inheritance",
        "is_correct": false
      },
      {
        "option_text": "To enable dynamic binding",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'encapsulation' mainly concerned with?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Bundling data and methods and restricting access",
        "is_correct": true
      },
      {
        "option_text": "Hiding data types from the user",
        "is_correct": false
      },
      {
        "option_text": "Making all methods static",
        "is_correct": false
      },
      {
        "option_text": "Using global variables",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is meant by 'tight coupling' in OOP?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "When classes are highly dependent on each other's implementations",
        "is_correct": true
      },
      {
        "option_text": "When classes are completely independent",
        "is_correct": false
      },
      {
        "option_text": "When objects are created dynamically",
        "is_correct": false
      },
      {
        "option_text": "When methods are overloaded",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'loose coupling' and why is it desirable?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "When classes have minimal dependencies on each other, making the system more flexible and maintainable",
        "is_correct": true
      },
      {
        "option_text": "When classes are tightly bound for performance",
        "is_correct": false
      },
      {
        "option_text": "When all classes inherit from a single base class",
        "is_correct": false
      },
      {
        "option_text": "When objects are destroyed immediately",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the 'Law of Demeter' (Principle of Least Knowledge)?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "A method should only talk to its immediate friends, not to strangers",
        "is_correct": true
      },
      {
        "option_text": "A class should have only one responsibility",
        "is_correct": false
      },
      {
        "option_text": "Objects should be immutable",
        "is_correct": false
      },
      {
        "option_text": "Methods should be short",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'coupling' in OOP design?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "The degree of interdependence between software modules",
        "is_correct": true
      },
      {
        "option_text": "The process of combining data and behavior",
        "is_correct": false
      },
      {
        "option_text": "The ability to override methods",
        "is_correct": false
      },
      {
        "option_text": "The number of methods in a class",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the main goal of achieving high cohesion and low coupling?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "To create more maintainable and flexible software",
        "is_correct": true
      },
      {
        "option_text": "To make programs run faster",
        "is_correct": false
      },
      {
        "option_text": "To reduce the number of classes",
        "is_correct": false
      },
      {
        "option_text": "To increase code reuse through inheritance",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'orthogonality' in software design?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "When features can be used independently without unexpected interactions",
        "is_correct": true
      },
      {
        "option_text": "When classes are arranged in a straight line",
        "is_correct": false
      },
      {
        "option_text": "When inheritance is used properly",
        "is_correct": false
      },
      {
        "option_text": "When all methods are public",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the difference between static and dynamic binding?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Static binding occurs at compile time, dynamic binding at runtime",
        "is_correct": true
      },
      {
        "option_text": "Static binding is slower than dynamic binding",
        "is_correct": false
      },
      {
        "option_text": "Dynamic binding only applies to variables",
        "is_correct": false
      },
      {
        "option_text": "There is no difference",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'late binding' or 'dynamic dispatch'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "The process of resolving method calls at runtime based on the actual object type",
        "is_correct": true
      },
      {
        "option_text": "Binding variables to values late in the program",
        "is_correct": false
      },
      {
        "option_text": "Delaying the creation of objects",
        "is_correct": false
      },
      {
        "option_text": "Using global variables",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the benefit of late binding in OOP?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "It enables polymorphism and more flexible code",
        "is_correct": true
      },
      {
        "option_text": "It makes programs run faster",
        "is_correct": false
      },
      {
        "option_text": "It reduces memory usage",
        "is_correct": false
      },
      {
        "option_text": "It simplifies the compiler",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'message passing' in OOP?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Objects communicating by sending messages (method calls) to each other",
        "is_correct": true
      },
      {
        "option_text": "Sending data over a network",
        "is_correct": false
      },
      {
        "option_text": "Using message queues in multithreading",
        "is_correct": false
      },
      {
        "option_text": "Printing output to the console",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is a 'friend class' in some OOP languages?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "A class that has access to the private and protected members of another class",
        "is_correct": true
      },
      {
        "option_text": "A class that inherits from another class",
        "is_correct": false
      },
      {
        "option_text": "A class that is used for testing",
        "is_correct": false
      },
      {
        "option_text": "A class that implements an interface",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'method resolution order' (MRO)?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "The order in which methods are searched for and executed in inheritance hierarchies",
        "is_correct": true
      },
      {
        "option_text": "The order in which classes are compiled",
        "is_correct": false
      },
      {
        "option_text": "The order in which objects are destroyed",
        "is_correct": false
      },
      {
        "option_text": "The order in which variables are initialized",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the purpose of the 'super' keyword in inheritance?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "To call methods from a parent class",
        "is_correct": true
      },
      {
        "option_text": "To create new objects",
        "is_correct": false
      },
      {
        "option_text": "To make methods static",
        "is_correct": false
      },
      {
        "option_text": "To define abstract methods",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'covariance' and 'contravariance' in the context of generics and inheritance?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Covariance allows a generic type to accept more derived types, contravariance allows it to accept less derived types",
        "is_correct": true
      },
      {
        "option_text": "They refer to the speed of method execution",
        "is_correct": false
      },
      {
        "option_text": "They are types of inheritance",
        "is_correct": false
      },
      {
        "option_text": "They relate to memory management",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the 'Open/Closed Principle'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Software entities should be open for extension but closed for modification",
        "is_correct": true
      },
      {
        "option_text": "Classes should be open to inheritance but closed to instantiation",
        "is_correct": false
      },
      {
        "option_text": "Methods should be open to overriding but closed to overloading",
        "is_correct": false
      },
      {
        "option_text": "Variables should be open for reading but closed for writing",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'dependency injection'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Supplying dependencies from outside a class to reduce coupling",
        "is_correct": true
      },
      {
        "option_text": "Creating all objects inside a class",
        "is_correct": false
      },
      {
        "option_text": "Using global variables for dependencies",
        "is_correct": false
      },
      {
        "option_text": "Inheriting from multiple classes",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the relationship between dependency injection and inversion of control?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Dependency injection is a technique to achieve inversion of control",
        "is_correct": true
      },
      {
        "option_text": "They are the same thing",
        "is_correct": false
      },
      {
        "option_text": "Inversion of control is a type of inheritance",
        "is_correct": false
      },
      {
        "option_text": "They are unrelated concepts",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the 'Single Responsibility Principle'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "A class should have only one reason to change",
        "is_correct": true
      },
      {
        "option_text": "A class should only have one method",
        "is_correct": false
      },
      {
        "option_text": "All classes should be small",
        "is_correct": false
      },
      {
        "option_text": "Methods should do only one thing",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'separation of concerns' in software design?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Dividing a program into distinct sections where each section addresses a separate concern",
        "is_correct": true
      },
      {
        "option_text": "Separating classes into different files",
        "is_correct": false
      },
      {
        "option_text": "Creating separate methods for each operation",
        "is_correct": false
      },
      {
        "option_text": "Using different programming languages",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the 'Liskov Substitution Principle'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Objects of a superclass should be replaceable with objects of a subclass without breaking the program",
        "is_correct": true
      },
      {
        "option_text": "Subclasses should not override methods",
        "is_correct": false
      },
      {
        "option_text": "All classes should inherit from a common base",
        "is_correct": false
      },
      {
        "option_text": "Inheritance should be avoided",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the 'Interface Segregation Principle'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Clients should not be forced to depend on interfaces they do not use",
        "is_correct": true
      },
      {
        "option_text": "All classes should implement a single interface",
        "is_correct": false
      },
      {
        "option_text": "Interfaces should be as large as possible",
        "is_correct": false
      },
      {
        "option_text": "Interfaces are not necessary",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the 'Dependency Inversion Principle'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "High-level modules should not depend on low-level modules; both should depend on abstractions",
        "is_correct": true
      },
      {
        "option_text": "Dependencies should be created using inheritance",
        "is_correct": false
      },
      {
        "option_text": "All dependencies must be concrete classes",
        "is_correct": false
      },
      {
        "option_text": "Dependencies should be inverted using reflection",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'SOLID' in OOP?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "An acronym for five design principles: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, and Dependency Inversion",
        "is_correct": true
      },
      {
        "option_text": "A type of class inheritance",
        "is_correct": false
      },
      {
        "option_text": "A memory management technique",
        "is_correct": false
      },
      {
        "option_text": "A programming language",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the 'diamond problem' in multiple inheritance?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "When a class inherits from two classes that have a common ancestor, causing ambiguity",
        "is_correct": true
      },
      {
        "option_text": "When a class has too many methods",
        "is_correct": false
      },
      {
        "option_text": "When inheritance creates a loop",
        "is_correct": false
      },
      {
        "option_text": "When a class cannot be instantiated",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "Which programming language feature helps solve the diamond problem?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Virtual inheritance or explicit method resolution",
        "is_correct": true
      },
      {
        "option_text": "Garbage collection",
        "is_correct": false
      },
      {
        "option_text": "Encapsulation",
        "is_correct": false
      },
      {
        "option_text": "Method overloading",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'favoring composition over inheritance'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "A design principle that suggests using composition to achieve code reuse instead of inheritance when possible",
        "is_correct": true
      },
      {
        "option_text": "Inheritance is always better than composition",
        "is_correct": false
      },
      {
        "option_text": "Composition should never be used",
        "is_correct": false
      },
      {
        "option_text": "They are equally good in all situations",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "Why is favoring composition over inheritance considered a good practice?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "It leads to more flexible designs and avoids problems with deep inheritance hierarchies",
        "is_correct": true
      },
      {
        "option_text": "It makes programs run faster",
        "is_correct": false
      },
      {
        "option_text": "It reduces the number of classes needed",
        "is_correct": false
      },
      {
        "option_text": "It simplifies the syntax",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is a 'mixin' in OOP?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "A class that contains methods for use by other classes without having to be the parent class",
        "is_correct": true
      },
      {
        "option_text": "A type of abstract class",
        "is_correct": false
      },
      {
        "option_text": "A design pattern for creating singletons",
        "is_correct": false
      },
      {
        "option_text": "A way to implement multiple inheritance",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'duck typing'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "If it walks like a duck and quacks like a duck, then it's a duck - focusing on object behavior rather than type",
        "is_correct": true
      },
      {
        "option_text": "A way to define abstract classes",
        "is_correct": false
      },
      {
        "option_text": "A method for creating interfaces",
        "is_correct": false
      },
      {
        "option_text": "A type of inheritance",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'object lifetime management'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "The process of creating and destroying objects and managing their memory",
        "is_correct": true
      },
      {
        "option_text": "Setting time limits on method execution",
        "is_correct": false
      },
      {
        "option_text": "Managing the order of method calls",
        "is_correct": false
      },
      {
        "option_text": "Controlling access to objects",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the difference between stack and heap memory in the context of object allocation?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Stack is for static allocation and automatic variables, heap is for dynamic allocation of objects",
        "is_correct": true
      },
      {
        "option_text": "Stack is faster than heap",
        "is_correct": false
      },
      {
        "option_text": "Heap is smaller than stack",
        "is_correct": false
      },
      {
        "option_text": "There is no difference",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "How does polymorphism improve code maintainability?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "By allowing different objects to be treated through a common interface",
        "is_correct": true
      },
      {
        "option_text": "By hiding data inside objects",
        "is_correct": false
      },
      {
        "option_text": "By creating multiple copies of code",
        "is_correct": false
      },
      {
        "option_text": "By limiting inheritance",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the benefit of using abstract classes instead of interfaces?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Abstract classes can provide shared code and state, interfaces cannot",
        "is_correct": true
      },
      {
        "option_text": "Interfaces can provide shared code, abstract classes cannot",
        "is_correct": false
      },
      {
        "option_text": "Abstract classes can be instantiated",
        "is_correct": false
      },
      {
        "option_text": "Interfaces allow multiple inheritance",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "Which of the following correctly describes 'dependency injection'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Supplying dependencies from outside a class to reduce coupling",
        "is_correct": true
      },
      {
        "option_text": "Making a class dependent on global variables",
        "is_correct": false
      },
      {
        "option_text": "Creating new instances inside a class",
        "is_correct": false
      },
      {
        "option_text": "Using static variables",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'late binding' in OOP?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Method to decide which function to call at runtime",
        "is_correct": true
      },
      {
        "option_text": "Binding variables to types at compile time",
        "is_correct": false
      },
      {
        "option_text": "Defining all methods as static",
        "is_correct": false
      },
      {
        "option_text": "Using final classes",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the difference between composition and inheritance?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Inheritance represents 'is-a' relationship, composition represents 'has-a' relationship",
        "is_correct": true
      },
      {
        "option_text": "Composition is faster than inheritance",
        "is_correct": false
      },
      {
        "option_text": "Inheritance allows code reuse, composition does not",
        "is_correct": false
      },
      {
        "option_text": "They are the same",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'inversion of control' (IoC)?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "A design principle where the control flow of a program is inverted, often managed by a framework",
        "is_correct": true
      },
      {
        "option_text": "A way to make all methods final",
        "is_correct": false
      },
      {
        "option_text": "A method to reverse inheritance",
        "is_correct": false
      },
      {
        "option_text": "A syntax for creating objects",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the 'factory method pattern' used for?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Defining an interface for creating objects, but letting subclasses alter the type of objects created",
        "is_correct": true
      },
      {
        "option_text": "Creating only one instance of a class",
        "is_correct": false
      },
      {
        "option_text": "Destroying objects automatically",
        "is_correct": false
      },
      {
        "option_text": "Cloning existing objects",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the 'singleton pattern'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "A design pattern that ensures a class has only one instance and provides a global point of access to it",
        "is_correct": true
      },
      {
        "option_text": "A class that can be instantiated multiple times",
        "is_correct": false
      },
      {
        "option_text": "A method that returns multiple values",
        "is_correct": false
      },
      {
        "option_text": "A way to delete objects",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'method overloading'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Defining multiple methods with the same name but different parameters",
        "is_correct": true
      },
      {
        "option_text": "Redefining a method in a subclass",
        "is_correct": false
      },
      {
        "option_text": "Deleting a method",
        "is_correct": false
      },
      {
        "option_text": "Making a method static",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'method overriding'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Providing a new implementation of a method in a subclass that is already defined in the parent class",
        "is_correct": true
      },
      {
        "option_text": "Creating a method with the same name and parameters in the same class",
        "is_correct": false
      },
      {
        "option_text": "Hiding a method from the parent class",
        "is_correct": false
      },
      {
        "option_text": "Making a method private",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'abstraction' in OOP?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Hiding complex implementation details and showing only essential features",
        "is_correct": true
      },
      {
        "option_text": "Making all methods public",
        "is_correct": false
      },
      {
        "option_text": "Using multiple inheritance",
        "is_correct": false
      },
      {
        "option_text": "Creating large classes",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is a 'constructor' in OOP?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "A special method called when an object is created to initialize its state",
        "is_correct": true
      },
      {
        "option_text": "A method to destroy an object",
        "is_correct": false
      },
      {
        "option_text": "A static method",
        "is_correct": false
      },
      {
        "option_text": "A method to override inheritance",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'aggregation' in OOP?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "A 'has-a' relationship where the child can exist independently of the parent",
        "is_correct": true
      },
      {
        "option_text": "A 'part-of' relationship where the child cannot exist without the parent",
        "is_correct": false
      },
      {
        "option_text": "A type of inheritance",
        "is_correct": false
      },
      {
        "option_text": "A way to make methods final",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'composition' in OOP?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "A 'part-of' relationship where the child cannot exist independently of the parent",
        "is_correct": true
      },
      {
        "option_text": "A 'has-a' relationship where the child can exist independently",
        "is_correct": false
      },
      {
        "option_text": "A type of polymorphism",
        "is_correct": false
      },
      {
        "option_text": "A way to override methods",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'static binding'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Binding that occurs at compile time, based on variable type",
        "is_correct": true
      },
      {
        "option_text": "Binding that occurs at runtime, based on object type",
        "is_correct": false
      },
      {
        "option_text": "Binding using reflection",
        "is_correct": false
      },
      {
        "option_text": "Binding using dependency injection",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'runtime polymorphism'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Method overriding, where the method to call is determined at runtime",
        "is_correct": true
      },
      {
        "option_text": "Method overloading, resolved at compile time",
        "is_correct": false
      },
      {
        "option_text": "Using static methods",
        "is_correct": false
      },
      {
        "option_text": "Creating abstract classes",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is the 'observer pattern'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "A design pattern where an object maintains a list of dependents and notifies them of changes",
        "is_correct": true
      },
      {
        "option_text": "A pattern for creating singletons",
        "is_correct": false
      },
      {
        "option_text": "A way to implement inheritance",
        "is_correct": false
      },
      {
        "option_text": "A method for garbage collection",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'deep inheritance hierarchy' problematic?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "It increases coupling, reduces flexibility, and makes code hard to maintain",
        "is_correct": true
      },
      {
        "option_text": "It improves performance",
        "is_correct": false
      },
      {
        "option_text": "It reduces memory usage",
        "is_correct": false
      },
      {
        "option_text": "It simplifies testing",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'interface-based programming'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Designing code around interfaces rather than concrete classes to improve flexibility",
        "is_correct": true
      },
      {
        "option_text": "Using only abstract classes",
        "is_correct": false
      },
      {
        "option_text": "Avoiding inheritance",
        "is_correct": false
      },
      {
        "option_text": "Making all methods static",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'refactoring' in OOP?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Restructuring existing code without changing its behavior to improve design",
        "is_correct": true
      },
      {
        "option_text": "Deleting old code",
        "is_correct": false
      },
      {
        "option_text": "Adding new features",
        "is_correct": false
      },
      {
        "option_text": "Changing the programming language",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'code smell' in OOP?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "A surface indication that usually corresponds to a deeper problem in the code",
        "is_correct": true
      },
      {
        "option_text": "A syntax error",
        "is_correct": false
      },
      {
        "option_text": "A compiler warning",
        "is_correct": false
      },
      {
        "option_text": "A runtime exception",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'design by contract'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "A methodology where methods have preconditions, postconditions, and invariants",
        "is_correct": true
      },
      {
        "option_text": "A way to write legal contracts for software",
        "is_correct": false
      },
      {
        "option_text": "A type of inheritance",
        "is_correct": false
      },
      {
        "option_text": "A method for dependency injection",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'template method pattern'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "A pattern where a method defines the skeleton of an algorithm, deferring some steps to subclasses",
        "is_correct": true
      },
      {
        "option_text": "A way to create templates for classes",
        "is_correct": false
      },
      {
        "option_text": "A method for cloning objects",
        "is_correct": false
      },
      {
        "option_text": "A syntax for generics",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'strategy pattern'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "A pattern that enables selecting an algorithm at runtime",
        "is_correct": true
      },
      {
        "option_text": "A way to make all methods static",
        "is_correct": false
      },
      {
        "option_text": "A method for inheritance",
        "is_correct": false
      },
      {
        "option_text": "A type of polymorphism",
        "is_correct": false
      }
    ]
  },
  {
    "topic": 37,
    "question_text": "What is 'command pattern'?",
    "level": "hard",
    "marks": 1,
    "options": [
      {
        "option_text": "Encapsulating a request as an object, allowing parameterization of clients with queues, requests, and operations",
        "is_correct": true
      },
      {
        "option_text": "A way to delete commands",
        "is_correct": false
      },
      {
        "option_text": "A syntax for comments",
        "is_correct": false
      },
      {
        "option_text": "A method for method overloading",
        "is_correct": false
      }
    ]
  }
]